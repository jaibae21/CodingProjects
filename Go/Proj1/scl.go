package main

import (
  "fmt"
  "log"
  "os"
  "bufio"
  "strings"
)

/*Project 1 - Simple Constraint Languages
Phoebe Coccia
CS424-02
09/21/22

Description: Takes an input file from the command line
and parses it to determine if the syntax is correct for the
simple constraint language specified below in BNF

<var> ::= U | V | W | X | Y | Z
<assign> -> <var> = <string>
<expression> -> <var> > <var>
              | <var> < <var>
              | <var> ! <var>
              | <var> ~ <var>

*/

var synGood bool; //global variable "syntax Good"
                  //false if bad syntax detected

func main() {
  synGood = true

  //command line argument: filename
  filename := os.Args[1:]


  //REMOVE LATER
   fmt.Println(filename)

  //converts filename variable from string[] to string
  filename2 := strings.Join(filename, "")
  //open file
  dat, err := os.Open(filename2)

  //error if no data in file
  if err != nil{
    log.Fatal(err)
  }
  //scanner: reads input file line-by-line
  scanner := bufio.NewScanner(dat)

  lineCnt := 0
  for scanner.Scan() {
  //tracks which line
  lineCnt++

    line := scanner.Text()          //get line from scanner
    s := strings.Split(line, " ")   //splits line into individual tokens

       i := 0
       //test first token 
       if s[i] == "U" || s[i] == "V" || s[i] == "W" || s[i] == "X" || s[i] == "Y" || s[i] == "Z" {
         sclVar(s, lineCnt, i)

       } else if s[i] == "="{
         sclAssign(s, lineCnt, i)

       } else if s[i] == "<" || s[i] == ">" || s[i] == "!" || s[i] == "~"{
         sclExpr(s, lineCnt, i)

       } else {

         sclString(s, lineCnt, i)
       }


     }
     if (synGood == true){
       fmt.Println("No Syntax errors detected. ", lineCnt, " lines processed" )
     }

    }


  //parses string in the SCL generated by
  //<assign> -> <var> = <string>
  func sclAssign (s []string, lineCnt int, i int){
        fmt.Println("Trying token ", s[i])
    firstTokenCheck(s, lineCnt)
    if (s[i+1] == "U" || s[i+1] == "V" || s[i+1] == "W" || s[i+1] == "X" || s[i+1] == "Y" || s[i+1] == "Z" || s[i+1] == "<" || s[i+1] == ">" || s[i+1] == "!" || s[i+1] == "~" || s[i+1] == "="){
      parseError(s[i+1], lineCnt)
    } else {
      sclString(s, lineCnt, i+1)
    }
  }

  //parses string in the SCL generated by
  //<expression> -> <var> > <var>
  // | etc...
  func sclExpr (s []string, lineCnt int, i int){
    fmt.Println("Trying token ", s[i])
    firstTokenCheck(s, lineCnt)
    if i+1 == len(s){
      return
    }
    if (s[i+1] == "U" || s[i+1] == "V" || s[i+1] == "W" || s[i+1] == "X" || s[i+1] == "Y" || s[i+1] == "Z"){
        sclVar(s, lineCnt, i+1)
    } else {
      parseError(s[i+1], lineCnt)
    }

  }

  //parses string in the SCL generated by
  //<var>
  func sclVar (s []string, lineCnt int, i int){
    fmt.Println("Trying token ", s[i])
    if i+1 == len(s){
      return
    }
    firstTokenCheck(s, lineCnt)
    if (s[i+1] == ">" || s[i+1] == "<" || s[i+1] == "!" || s[i+1] == "~"){
      sclExpr(s, lineCnt, i+1)
    } else if (s[i+1] == "="){
      sclAssign(s, lineCnt, i+1)
    } else {
      parseError(s[i+1], lineCnt)
    }
  }

  //parses string in the SCL generated by
  //<string>
  //doesn't work. i don't know how to fix it
  //there is no set of logic that makes it output an error correctly
  //should be. if at end of line. return. if not at end of line ERROR.
  func sclString (s []string, lineCnt int, i int){
    fmt.Println("Trying token ", s[i])
    firstTokenCheck(s, lineCnt)
    if s[i] == s[len(s)-1]{
      return
    } else if s[i] != s[len(s)-1]{
      //parseError(s[i+1], lineCnt)
    }

  }

  //Prints error stating offending token and line
  func parseError(s string, lineCnt int){
    fmt.Println("Invalid syntax detected! Token ", s, " at line", lineCnt, " is not correct!")
    synGood = false
  }

  //Checks first token of any given line
  //according to BNF every beginning token should be
  // <var>
  func firstTokenCheck(s []string, lineCnt int){
    if s[0] != "U" && s[0] != "V" && s[0] != "W" && s[0] != "X" && s[0] != "Y" && s[0] != "Z"{
      parseError(s[0], lineCnt)
    }
  }
